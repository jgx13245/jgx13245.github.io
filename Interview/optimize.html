<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>新鲜面试题 | 小奶鑫的主页</title>
    <meta name="description" content="冀光鑫的博客">
    
    
    <link rel="preload" href="/assets/css/0.styles.5e739af7.css" as="style"><link rel="preload" href="/assets/js/app.296096c9.js" as="script"><link rel="preload" href="/assets/js/2.93ca5cf4.js" as="script"><link rel="preload" href="/assets/js/21.050f4549.js" as="script"><link rel="prefetch" href="/assets/js/10.9da8529d.js"><link rel="prefetch" href="/assets/js/11.0c495190.js"><link rel="prefetch" href="/assets/js/12.f4413bf4.js"><link rel="prefetch" href="/assets/js/13.53177617.js"><link rel="prefetch" href="/assets/js/14.1907b3b2.js"><link rel="prefetch" href="/assets/js/15.751bef3a.js"><link rel="prefetch" href="/assets/js/16.cb7376b9.js"><link rel="prefetch" href="/assets/js/17.70c81bbb.js"><link rel="prefetch" href="/assets/js/18.fc239933.js"><link rel="prefetch" href="/assets/js/19.4543169f.js"><link rel="prefetch" href="/assets/js/20.0e80446e.js"><link rel="prefetch" href="/assets/js/22.5c39a6b4.js"><link rel="prefetch" href="/assets/js/23.11fd4741.js"><link rel="prefetch" href="/assets/js/24.68d31a36.js"><link rel="prefetch" href="/assets/js/25.c463a95c.js"><link rel="prefetch" href="/assets/js/26.8ad8574a.js"><link rel="prefetch" href="/assets/js/27.96ed4f89.js"><link rel="prefetch" href="/assets/js/28.e61163e0.js"><link rel="prefetch" href="/assets/js/29.4eb96332.js"><link rel="prefetch" href="/assets/js/3.ddf3a79c.js"><link rel="prefetch" href="/assets/js/30.3f3303d4.js"><link rel="prefetch" href="/assets/js/31.60daf47b.js"><link rel="prefetch" href="/assets/js/32.cb4bce1b.js"><link rel="prefetch" href="/assets/js/33.113ec68f.js"><link rel="prefetch" href="/assets/js/34.21aa3ad6.js"><link rel="prefetch" href="/assets/js/35.9dca379f.js"><link rel="prefetch" href="/assets/js/4.7eb02300.js"><link rel="prefetch" href="/assets/js/5.c4657d68.js"><link rel="prefetch" href="/assets/js/6.4851ba8e.js"><link rel="prefetch" href="/assets/js/7.db35e16c.js"><link rel="prefetch" href="/assets/js/8.951bbc33.js"><link rel="prefetch" href="/assets/js/9.afbec623.js">
    <link rel="stylesheet" href="/assets/css/0.styles.5e739af7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">小奶鑫的主页</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/Interview/" class="nav-link router-link-active">面试基础</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端三剑客</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/HTML/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/CSS/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/EditPrinciple/" class="nav-link">编译原理</a></li><li class="dropdown-item"><!----> <a href="/Http/" class="nav-link">http原理</a></li><li class="dropdown-item"><!----> <a href="/DesignModle/" class="nav-link">设计模式</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/HandFunction/" class="nav-link">手写前端方法</a></li><li class="dropdown-item"><!----> <a href="/DataStructure/" class="nav-link">数据结构</a></li><li class="dropdown-item"><!----> <a href="/algorithm/" class="nav-link">算法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">运行环境</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/BrowserApi/" class="nav-link">浏览器的API</a></li><li class="dropdown-item"><!----> <a href="/BrowserPrinciple/" class="nav-link">浏览器的缓存原理</a></li><li class="dropdown-item"><!----> <a href="/Node/" class="nav-link">Node</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">框架和类库</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/React/" class="nav-link">react</a></li><li class="dropdown-item"><!----> <a href="/Vue/" class="nav-link">vue</a></li><li class="dropdown-item"><!----> <a href="/MoreDevelopment/" class="nav-link">多端开发</a></li><li class="dropdown-item"><!----> <a href="/ES6/" class="nav-link">ES6</a></li><li class="dropdown-item"><!----> <a href="/DeBugs/" class="nav-link">开发和调试</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端工程</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/webpack/" class="nav-link">webpack</a></li><li class="dropdown-item"><!----> <a href="/Git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/nginx/" class="nav-link">nginx</a></li><li class="dropdown-item"><!----> <a href="/UpPerformance/" class="nav-link">性能提升</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端安全</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Xss/" class="nav-link">xss</a></li><li class="dropdown-item"><!----> <a href="/Csrf/" class="nav-link">csrf</a></li><li class="dropdown-item"><!----> <a href="/HttpAttack/" class="nav-link">http劫持</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/Interview/" class="nav-link router-link-active">面试基础</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端三剑客</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/HTML/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/CSS/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/EditPrinciple/" class="nav-link">编译原理</a></li><li class="dropdown-item"><!----> <a href="/Http/" class="nav-link">http原理</a></li><li class="dropdown-item"><!----> <a href="/DesignModle/" class="nav-link">设计模式</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">数据结构和算法</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/HandFunction/" class="nav-link">手写前端方法</a></li><li class="dropdown-item"><!----> <a href="/DataStructure/" class="nav-link">数据结构</a></li><li class="dropdown-item"><!----> <a href="/algorithm/" class="nav-link">算法</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">运行环境</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/BrowserApi/" class="nav-link">浏览器的API</a></li><li class="dropdown-item"><!----> <a href="/BrowserPrinciple/" class="nav-link">浏览器的缓存原理</a></li><li class="dropdown-item"><!----> <a href="/Node/" class="nav-link">Node</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">框架和类库</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/React/" class="nav-link">react</a></li><li class="dropdown-item"><!----> <a href="/Vue/" class="nav-link">vue</a></li><li class="dropdown-item"><!----> <a href="/MoreDevelopment/" class="nav-link">多端开发</a></li><li class="dropdown-item"><!----> <a href="/ES6/" class="nav-link">ES6</a></li><li class="dropdown-item"><!----> <a href="/DeBugs/" class="nav-link">开发和调试</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端工程</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/webpack/" class="nav-link">webpack</a></li><li class="dropdown-item"><!----> <a href="/Git/" class="nav-link">Git</a></li><li class="dropdown-item"><!----> <a href="/nginx/" class="nav-link">nginx</a></li><li class="dropdown-item"><!----> <a href="/UpPerformance/" class="nav-link">性能提升</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端安全</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Xss/" class="nav-link">xss</a></li><li class="dropdown-item"><!----> <a href="/Csrf/" class="nav-link">csrf</a></li><li class="dropdown-item"><!----> <a href="/HttpAttack/" class="nav-link">http劫持</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/Interview/" class="sidebar-link">Js基础知识面试</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Interview/#原始类型" class="sidebar-link">原始类型</a></li><li class="sidebar-sub-header"><a href="/Interview/#mvc-mvp-mvvm-的区别" class="sidebar-link">Mvc Mvp Mvvm 的区别</a></li><li class="sidebar-sub-header"><a href="/Interview/#this的讲解" class="sidebar-link">this的讲解</a></li><li class="sidebar-sub-header"><a href="/Interview/#promise理解" class="sidebar-link">promise理解</a></li><li class="sidebar-sub-header"><a href="/Interview/#原型链" class="sidebar-link">原型链</a></li><li class="sidebar-sub-header"><a href="/Interview/#异步执行的顺序理解" class="sidebar-link">异步执行的顺序理解</a></li><li class="sidebar-sub-header"><a href="/Interview/#闭包" class="sidebar-link">闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Interview/#变量的作用域" class="sidebar-link">变量的作用域</a></li><li class="sidebar-sub-header"><a href="/Interview/#如何从外部读取局部变量？" class="sidebar-link">如何从外部读取局部变量？</a></li><li class="sidebar-sub-header"><a href="/Interview/#闭包的概念" class="sidebar-link">闭包的概念</a></li><li class="sidebar-sub-header"><a href="/Interview/#闭包的用途" class="sidebar-link">闭包的用途</a></li><li class="sidebar-sub-header"><a href="/Interview/#闭包的应用实例" class="sidebar-link">闭包的应用实例</a></li><li class="sidebar-sub-header"><a href="/Interview/#匿名函数和闭包之间的关系" class="sidebar-link">匿名函数和闭包之间的关系</a></li><li class="sidebar-sub-header"><a href="/Interview/#for循环经典闭包案子的分析" class="sidebar-link">for循环经典闭包案子的分析</a></li><li class="sidebar-sub-header"><a href="/Interview/#闭包需要注意的地方" class="sidebar-link">闭包需要注意的地方</a></li></ul></li><li class="sidebar-sub-header"><a href="/Interview/#数组的几个用法" class="sidebar-link">数组的几个用法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Interview/#_1-reduce" class="sidebar-link">1. reduce</a></li></ul></li></ul></li><li><a href="/Interview/optimize.html" class="active sidebar-link">新鲜面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Interview/optimize.html#this-vm" class="sidebar-link">this === vm ?</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#promise" class="sidebar-link">promise</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#class" class="sidebar-link">class</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#继承" class="sidebar-link">继承</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#函数" class="sidebar-link">*函数</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#async-await" class="sidebar-link">async await</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#import-require" class="sidebar-link">import require</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#mvvm" class="sidebar-link">mvvm</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#循环一个对象，对象更新了，页面没有更新" class="sidebar-link">循环一个对象，对象更新了，页面没有更新</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#对babel怎么理解" class="sidebar-link">对babel怎么理解</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#vue的指令" class="sidebar-link">vue的指令</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#不用vue-cli写项目" class="sidebar-link">不用vue-cli写项目</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#_14-项目可以有多个vue对象，详解下" class="sidebar-link">14. 项目可以有多个vue对象，详解下</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#_15-路由守卫" class="sidebar-link">15. 路由守卫</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#_16-methods和computed的区别" class="sidebar-link">16. methods和computed的区别</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#_17-keep-alive-避免重新渲染" class="sidebar-link">17. keep-alive 避免重新渲染</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#_18-循环一个对象，对象更新了，页面没有更新" class="sidebar-link">18. 循环一个对象，对象更新了，页面没有更新</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#_19-mvvm模式如何理解" class="sidebar-link">19. mvvm模式如何理解</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#_21-es6-let-const-var的区别" class="sidebar-link">21. es6 let const var的区别</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#promise的原理-和-状态（rejict）" class="sidebar-link">promise的原理  和 状态（rejict）</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#状态是否可逆，为什么" class="sidebar-link">状态是否可逆，为什么</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#盒模型有几种" class="sidebar-link">盒模型有几种</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#回流和重绘" class="sidebar-link">回流和重绘</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#css3有哪些新特性" class="sidebar-link">css3有哪些新特性</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#css3的动画" class="sidebar-link">css3的动画</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#css3选择器" class="sidebar-link">css3选择器</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#ulli3-如何选择第二个li" class="sidebar-link">ulli3 如何选择第二个li</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#rem的原理" class="sidebar-link">rem的原理</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#定位" class="sidebar-link">定位</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#ajax（原生-jq）" class="sidebar-link">ajax（原生 jq）</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#圣杯布局" class="sidebar-link">圣杯布局</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#箭头函数的处理-原理-特性-this指向" class="sidebar-link">箭头函数的处理 原理 特性 this指向</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#es6都用到什么" class="sidebar-link">ES6都用到什么</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#set-map-for循环数组" class="sidebar-link">set map for循环数组</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#git命令" class="sidebar-link">git命令</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#npm用来做什么-和webpack的区别" class="sidebar-link">npm用来做什么 和webpack的区别</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#webpack是管理的包" class="sidebar-link">webpack是管理的包</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#vue-router-两个路由的模式-hash-地址栏上是否带" class="sidebar-link">vue router 两个路由的模式 hash 地址栏上是否带##</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#vuex-什么时候要用到" class="sidebar-link">vuex 什么时候要用到</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#vue的cli-webpack的配置在那个文件夹下找" class="sidebar-link">vue的cli webpack的配置在那个文件夹下找</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#axios-的封装" class="sidebar-link">axios 的封装</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#了解node么" class="sidebar-link">了解node么</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#浏览器的缓存都有那些" class="sidebar-link">浏览器的缓存都有那些</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#深拷贝" class="sidebar-link">深拷贝</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#git命令-2" class="sidebar-link">git命令</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#解决跨域的方法" class="sidebar-link">解决跨域的方法</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#_1-手写一个防抖和一个节流" class="sidebar-link">1. 手写一个防抖和一个节流</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#_2-手写一个promise" class="sidebar-link">2. 手写一个promise</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#_3-虚拟dom原理" class="sidebar-link">3. 虚拟dom原理</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#_4-手写apply-call，使用apply实现bind" class="sidebar-link">4. 手写apply call，使用apply实现bind</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#_5-发布订阅模式怎么实现？" class="sidebar-link">5. 发布订阅模式怎么实现？</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#_6-vue中-emit、-on实现机制" class="sidebar-link">6. vue中$emit、$on实现机制</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#_7-闭包应用" class="sidebar-link">7. 闭包应用</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#_8-computed、methods区别" class="sidebar-link">8. computed、methods区别</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#_9-懒加载的实现原理" class="sidebar-link">9. 懒加载的实现原理</a></li><li class="sidebar-sub-header"><a href="/Interview/optimize.html#_10-其他问题" class="sidebar-link">10. 其他问题</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="新鲜面试题"><a href="#新鲜面试题" aria-hidden="true" class="header-anchor">#</a> 新鲜面试题</h1> <h2 id="this-vm"><a href="#this-vm" aria-hidden="true" class="header-anchor">#</a> this === vm ?</h2> <p>只是一个箭头函数的指向问题。实例化vue的时候，vue的方法使用call指向了this.$option.data.所以 this = this.$option.data。就乐意直接使用this.xx的数据</p> <h2 id="promise"><a href="#promise" aria-hidden="true" class="header-anchor">#</a> promise</h2> <p>编写一个promise</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> time <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>time<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">124</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">999</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Pro</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">fun</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseValue <span class="token operator">=</span> <span class="token string">''</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseStatus <span class="token operator">=</span> <span class="token string">'pending'</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fun<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">then</span> <span class="token punctuation">(</span><span class="token parameter">fun</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseList<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fun<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span>
  <span class="token punctuation">}</span>
  <span class="token function">resolve</span> <span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseStatus <span class="token operator">=</span> <span class="token string">'resolved'</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseValue <span class="token operator">=</span> v
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">reject</span> <span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseStatus <span class="token operator">=</span> <span class="token string">'rejected'</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseValue <span class="token operator">=</span> v
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 递归函数</span>
  <span class="token function">go</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseStatus <span class="token operator">!==</span> <span class="token string">'pending'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseList<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseList<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseValue<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">Pro</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        a<span class="token punctuation">.</span>PromiseList <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseList
        a<span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseValue <span class="token operator">=</span> a
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>promise源码实现的大概思路</p> <h2 id="class"><a href="#class" aria-hidden="true" class="header-anchor">#</a> class</h2> <p>其中 constructor 方法是类的构造函数，是一个默认方法，通过 new 命令创建对象实例时，class必须要用new命令创建，不然会报错
js规定一个类必须有 constructor 方法，自动执行，</p> <p>class继承中，子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ES6 要求，子类的构造函数必须执行一次 super 函数，否则会报错。</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在 constructor 中必须调用 super 方法，因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工,而 super 就代表了父类的构造函数。//// super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B，</span>
<span class="token comment">//  super() 在这里相当于 ```A.prototype.constructor.call(this, props)``。</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token punctuation">}</span>
  <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">7</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">x</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">10</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">2</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 10</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token comment">// 2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 总结</span>

<span class="token comment">// 1. 父类，子类都必须有constructor函数，没有就默认添加执行</span>
<span class="token comment">// 2. 子类如果继承，必须使用super关键字.子类没有this. 必选使用super继承父类的方法个属性，构建自己的实例 this</span>
<span class="token comment">// 3. 子类中，如果使用super.xx相当于调用父类的Prototype的方法或者属性，如果没有，就去父类的方法里面找。</span>
<span class="token comment">// 4. 子类中，如果使用，super.xx = yy  修改属性，不会修改父类的，而是修改子类的。修改的话，super.xx=yy 相当于this.xx =yy</span>
</code></pre></div><h2 id="继承"><a href="#继承" aria-hidden="true" class="header-anchor">#</a> 继承</h2> <h2 id="函数"><a href="#函数" aria-hidden="true" class="header-anchor">#</a> *函数</h2> <h2 id="async-await"><a href="#async-await" aria-hidden="true" class="header-anchor">#</a> async await</h2> <h2 id="import-require"><a href="#import-require" aria-hidden="true" class="header-anchor">#</a> import require</h2> <p>import和require都是被模块化所使用。</p> <p>require 是 AMD规范引入方式</p> <p>import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法</p> <p>require是运行时调用，所以require理论上可以运用在代码的任何地方</p> <p>import是编译时调用，所以必须放在文件开头</p> <p>require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量</p> <p>import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// require</span>

<span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>
exports<span class="token punctuation">.</span>fs <span class="token operator">=</span> fs
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> fs
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// import</span>

<span class="token keyword">import</span> fs <span class="token keyword">from</span> <span class="token string">'fs'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span><span class="token keyword">default</span> <span class="token keyword">as</span> fs<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'fs'</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> fs <span class="token keyword">from</span> <span class="token string">'fs'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>readFile<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'fs'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>readFile <span class="token keyword">as</span> read<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'fs'</span>
<span class="token keyword">import</span> fs<span class="token punctuation">,</span> <span class="token punctuation">{</span>readFile<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'fs'</span>
</code></pre></div><h2 id="mvvm"><a href="#mvvm" aria-hidden="true" class="header-anchor">#</a> mvvm</h2> <h2 id="循环一个对象，对象更新了，页面没有更新"><a href="#循环一个对象，对象更新了，页面没有更新" aria-hidden="true" class="header-anchor">#</a> 循环一个对象，对象更新了，页面没有更新</h2> <hr> <ol><li>为什么离职 想要取得更长久的进步。</li></ol> <hr> <ol start="3"><li>讲下vuex</li></ol> <p>就是全局状态管理，四个状态，state,getter,mutation,action..  单项数据流。必须经过mutation才能改变数据。</p> <ol start="4"><li>vuex里面的model怎么用</li> <li>vuex里面的多个model，多个store1</li> <li>vuex里面的简写函数</li> <li>vue router和a标签的区别</li> <li>vue的生命周期及做什么</li></ol> <p>（1）beforeCreate中拿不到任何数据，它在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p> <p>（2）created中已经可以拿到data中的数据了，但是dom还没有挂载。会判断有无el，如果没有el则停止后面的模板挂载。
在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。</p> <p>（3）beforeMount 和 created 拿到的数据相同 在挂载开始之前被调用：相关的 render 函数首次被调用。</p> <p>（4）mounted中el被创建dom已经更新，vue实例对象中有template参数选项，则将其作为模板编译成render函数，编译优先级render函数选项 &gt; template选项</p> <pre><code>使用场景:常用于获取VNode信息和操作，ajax请求
</code></pre> <p>（5）由于beforeUpdate更新之前，和updated更新之后</p> <p>（6）beforeDestroyed 和 destroyed   销毁之前  销毁之后</p> <ol start="9"><li><p>createed想更改DOM，怎么做？ nextTick</p></li> <li><p>vue父子组件传值。传引用</p> <div class="language- extra-class"><pre class="language-text"><code>1. props
2. emit, on
3. eventbus
4. vuex
5. 路由传值
6. $ref
7. provide inject

</code></pre></div></li></ol> <h2 id="对babel怎么理解"><a href="#对babel怎么理解" aria-hidden="true" class="header-anchor">#</a> 对babel怎么理解</h2> <h2 id="vue的指令"><a href="#vue的指令" aria-hidden="true" class="header-anchor">#</a> vue的指令</h2> <div class="language- extra-class"><pre class="language-text"><code>v-model
v-bind
v-on
v-text
v-html
v-pre
v-clock
v-show
v-if
v-else
v-else-if
v-slot
v-once
v-for
</code></pre></div><h2 id="不用vue-cli写项目"><a href="#不用vue-cli写项目" aria-hidden="true" class="header-anchor">#</a> 不用vue-cli写项目</h2> <h2 id="_14-项目可以有多个vue对象，详解下"><a href="#_14-项目可以有多个vue对象，详解下" aria-hidden="true" class="header-anchor">#</a> 14. 项目可以有多个vue对象，详解下</h2> <div class="language- extra-class"><pre class="language-text"><code>eventbus
</code></pre></div><h2 id="_15-路由守卫"><a href="#_15-路由守卫" aria-hidden="true" class="header-anchor">#</a> 15. 路由守卫</h2> <div class="language- extra-class"><pre class="language-text"><code>beforeEach(from, to, next)
</code></pre></div><h2 id="_16-methods和computed的区别"><a href="#_16-methods和computed的区别" aria-hidden="true" class="header-anchor">#</a> 16. methods和computed的区别</h2> <h2 id="_17-keep-alive-避免重新渲染"><a href="#_17-keep-alive-避免重新渲染" aria-hidden="true" class="header-anchor">#</a> 17. keep-alive 避免重新渲染</h2> <h2 id="_18-循环一个对象，对象更新了，页面没有更新"><a href="#_18-循环一个对象，对象更新了，页面没有更新" aria-hidden="true" class="header-anchor">#</a> 18. 循环一个对象，对象更新了，页面没有更新</h2> <h2 id="_19-mvvm模式如何理解"><a href="#_19-mvvm模式如何理解" aria-hidden="true" class="header-anchor">#</a> 19. mvvm模式如何理解</h2> <div class="language- extra-class"><pre class="language-text"><code>m: Model数据流 v: View视图 vm: ViewModel，连接v和m的对象
m和v是没有关系的，但是v和vm是双向绑定的，m改变的时候，vm也跟着改变，vm也会及时更新m，m改变的时候，也会改变vm，vm和m是双向绑定的。
</code></pre></div><ol start="20"><li>谁是vm，model是啥</li></ol> <h2 id="_21-es6-let-const-var的区别"><a href="#_21-es6-let-const-var的区别" aria-hidden="true" class="header-anchor">#</a> 21. es6 let const var的区别</h2> <p>let 暂时性死区，定义一个变量的时候，就不能被代码块一以外使用</p> <p>const 定义常量，一旦定义，就不能在下面修改，</p> <p>var 弱类型定义变量。变量提升</p> <ol start="22"><li>解构赋值</li> <li>async await</li> <li>import require</li> <li>引用一个文件的实际操作，</li> <li>引用一个文件和引入一个函数的区别</li> <li>支持动态引入么</li> <li>通过什么方式学习</li> <li>class原理和写法</li> <li>继承</li> <li>创建对象的方法</li> <li>组合继承有哪些</li> <li></li></ol> <p>######## 作业帮面试</p> <ul><li>调用支付，调用code，异步调用code的方法</li> <li>es6 做异步怎么做 promise</li></ul> <h2 id="promise的原理-和-状态（rejict）"><a href="#promise的原理-和-状态（rejict）" aria-hidden="true" class="header-anchor">#</a> promise的原理  和 状态（rejict）</h2> <p>原理就是一个解决异步回调的函数，语法糖，</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> time <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'执行成功'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'执行失败'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

test<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">erroe</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="状态是否可逆，为什么"><a href="#状态是否可逆，为什么" aria-hidden="true" class="header-anchor">#</a> 状态是否可逆，为什么</h2> <h2 id="盒模型有几种"><a href="#盒模型有几种" aria-hidden="true" class="header-anchor">#</a> 盒模型有几种</h2> <h2 id="回流和重绘"><a href="#回流和重绘" aria-hidden="true" class="header-anchor">#</a> 回流和重绘</h2> <h2 id="css3有哪些新特性"><a href="#css3有哪些新特性" aria-hidden="true" class="header-anchor">#</a> css3有哪些新特性</h2> <h2 id="css3的动画"><a href="#css3的动画" aria-hidden="true" class="header-anchor">#</a> css3的动画</h2> <h2 id="css3选择器"><a href="#css3选择器" aria-hidden="true" class="header-anchor">#</a> css3选择器</h2> <h2 id="ulli3-如何选择第二个li"><a href="#ulli3-如何选择第二个li" aria-hidden="true" class="header-anchor">#</a> ul<em>li</em>3 如何选择第二个li</h2> <pre><code>li:nth-child(2)
</code></pre> <h2 id="rem的原理"><a href="#rem的原理" aria-hidden="true" class="header-anchor">#</a> rem的原理</h2> <h2 id="定位"><a href="#定位" aria-hidden="true" class="header-anchor">#</a> 定位</h2> <p>fixed absolute relative  static</p> <h2 id="ajax（原生-jq）"><a href="#ajax（原生-jq）" aria-hidden="true" class="header-anchor">#</a> ajax（原生 jq）</h2> <h2 id="圣杯布局"><a href="#圣杯布局" aria-hidden="true" class="header-anchor">#</a> 圣杯布局</h2> <h2 id="箭头函数的处理-原理-特性-this指向"><a href="#箭头函数的处理-原理-特性-this指向" aria-hidden="true" class="header-anchor">#</a> 箭头函数的处理 原理 特性 this指向</h2> <p>不能构造，本身没有this,看上下文的this指向</p> <h2 id="es6都用到什么"><a href="#es6都用到什么" aria-hidden="true" class="header-anchor">#</a> ES6都用到什么</h2> <h2 id="set-map-for循环数组"><a href="#set-map-for循环数组" aria-hidden="true" class="header-anchor">#</a> set map for循环数组</h2> <h2 id="git命令"><a href="#git命令" aria-hidden="true" class="header-anchor">#</a> git命令</h2> <h2 id="npm用来做什么-和webpack的区别"><a href="#npm用来做什么-和webpack的区别" aria-hidden="true" class="header-anchor">#</a> npm用来做什么 和webpack的区别</h2> <p>npm是个代码仓库。webpack是个模块打包工具</p> <h2 id="webpack是管理的包"><a href="#webpack是管理的包" aria-hidden="true" class="header-anchor">#</a> webpack是管理的包</h2> <h2 id="vue-router-两个路由的模式-hash-地址栏上是否带"><a href="#vue-router-两个路由的模式-hash-地址栏上是否带" aria-hidden="true" class="header-anchor">#</a> vue router 两个路由的模式 hash 地址栏上是否带##</h2> <p>hans带  history不带 区别什么</p> <h2 id="vuex-什么时候要用到"><a href="#vuex-什么时候要用到" aria-hidden="true" class="header-anchor">#</a> vuex 什么时候要用到</h2> <pre><code>需要频繁的传递数据的时候
</code></pre> <h2 id="vue的cli-webpack的配置在那个文件夹下找"><a href="#vue的cli-webpack的配置在那个文件夹下找" aria-hidden="true" class="header-anchor">#</a> vue的cli webpack的配置在那个文件夹下找</h2> <pre><code>cli2的时候到build里面找   cli3的话需要自己在根目录创建vue.config.js、在里面创建
</code></pre> <h2 id="axios-的封装"><a href="#axios-的封装" aria-hidden="true" class="header-anchor">#</a> axios 的封装</h2> <h2 id="了解node么"><a href="#了解node么" aria-hidden="true" class="header-anchor">#</a> 了解node么</h2> <h2 id="浏览器的缓存都有那些"><a href="#浏览器的缓存都有那些" aria-hidden="true" class="header-anchor">#</a> 浏览器的缓存都有那些</h2> <pre><code>强缓存  弱缓存（协商缓存）
</code></pre> <h2 id="深拷贝"><a href="#深拷贝" aria-hidden="true" class="header-anchor">#</a> 深拷贝</h2> <h2 id="git命令-2"><a href="#git命令-2" aria-hidden="true" class="header-anchor">#</a> git命令</h2> <ul><li><code>console.log(1);setTimeout(function(){ console.log(2)}, 0);console.log(3); // 1,3,2</code></li> <li>是因为js是单线程的 而js实现异步是靠任务队列调度的 异步的会去队尾排队等待执行 而任务队列还可以细分为MacroTask Queue和MicoTask Queue两类 setTimeout属于前者，promise属于后者</li></ul> <p>######## 百度
first
笔试
比较重要的几个题:
一个 是while 循环 + 异 步 ，考察的是任务队列 答案就是循环最后一次的输出的值
二个 是bind call apply 区别， 能自己实现bind函数嘛， 加分项
三个 盒模型，主要是怪异和模型和标准盒模型的定义区别
<code>js // 标准盒模型是 总宽度= 设置的宽+2border+2margin+2padding // 怪异盒模型是 总宽度= 设置的宽+2margin （设置的宽 = content+border+padding） // 改变方式： 标准： box-sizing: content-box 怪异 box-sizing: border-box</code>
四个 inline-block 和 inline元素的区别
<code>js block 单独占一行。 inline不能设置宽高。不会占一行，会自动向右排列 inline-block 是有blcok的属性可以设置宽高，同时不会单独占一行。</code>
五个 居中的方式主要是竖直居中
<code>css 1.flex布局 2.position定位 transform: translate(-50%, -50%)</code>
六个 性能优化，尽量从多角度去谈
七个 有个数组去重的直接用[...new Set(arr)] 就可以了
剩下的都比较简单 有考察变量声明提前的
然后谈一下自己擅长的东西
seond
面试
也会有一些笔试的东西的但是都比较拔高的
一个 看下underScore 要了解节流函数 和 防抖函数 的用途和区别，以及原理
二个 模拟history的工作模式 要搞清楚history 都有哪些方法，是怎么实现的 重点是 go 和pushState
三个 nodejs 会谈的比较多，异步啊，代理啊，nginx嘛，代理实现的原理
四个 还会根据你之前一轮的情况问一些针对性的问题
third
面试
一个 布局 地位的问题 使用fixed定位一个input在移动设备屏幕的bottom 但是输入法会遮 盖 你得输入框，怎么解决 有两个方案 一个是使用flex 竖直进行布局，中间的部分flex设置 为1 input所在的div固定高度 另一个用js获取高度实时计算改变定位方式
二个 懒加载的实现原理 这个很重要
三个 如何封装sdk 主要考察面向对象的编程思维 封装一个注册登录的界面还有校验的界面 四个 一些移动端兼容的问题比如flex 定位之类的
五个 自己擅长什么</p> <p>######## 搜狐</p> <ol><li><p>自我介绍（自己和项目）
我13-17年在河南师范大学读的物联网工程专业，是统招的本科。16年11月，在国美就职，目前还是就职状态。在国美快两年了，也接触了不少的项目。
商户系统的三个前端项目，刚开始的一期和后来又开展了二期，是我和我同事四个人一块做的。我当时主要负责做商户的前端系统和另一个同事。两个人负责前端，两个人负责后端的。
美易分公众号的维护
weex项目
活动配置项目一期和二期
息费拆分</p></li> <li><p>你觉得你的哪一项强一些(HTML JS CSS)</p></li> <li><p>语义合理、结构清晰、易维护 你怎么理解的</p></li> <li><p>你们的团队怎么构成，分享之类的</p></li> <li><p>各个浏览器对css样式的支持不太一样，我们需要用reset.css把他们做成一致的</p></li> <li><p>盒模型是什么</p></li> <li><p>清浮动</p></li></ol> <ul><li>overflow： hidden  形成了bfc</li> <li>clear: both</li> <li>父浮子自浮</li> <li>最后一个兄弟浮动</li> <li>设置高度</li> <li>overflow: hidden;</li> <li>clearfix;</li></ul> <div class="language- extra-class"><pre class="language-text"><code>.clearfix :after{
	  content: '.';
    display: block;
    clear: both;
    visibility: hidden;
    height: 0;
}
</code></pre></div><ul><li>flex布局</li> <li>后面加空div，空div  clear：both</li></ul> <ol start="8"><li>图片 jpeg 和 png</li></ol> <ul><li>jpeg是有损压缩 png是无损压缩</li> <li>png 透明度</li> <li>图片的格式有gif、png、jpg、webp、png-8、png-24、svg
png后的数字代表2^8色，png-8支持索引透明和alpha透明。png-24不支持。
jpg有损压缩，不支持透明和动画，支持所有浏览。
gif只能存储256种颜色，支持动画和透明，占用空间小。
png占用空间大。</li></ul> <table><thead><tr><th>图片格式</th> <th>压缩方式</th> <th>透明度</th> <th>动画</th> <th>浏览器</th> <th>适应场景</th></tr></thead> <tbody><tr><td>jpeg</td> <td>有损压缩</td> <td>不支持</td> <td>不支持</td> <td>*</td> <td>复杂颜色及形状、照片</td></tr> <tr><td>gif</td> <td>无损压缩</td> <td>支持</td> <td>支持</td> <td>*</td> <td>简单颜色、动画</td></tr> <tr><td>png</td> <td>无损压缩</td> <td>支持</td> <td>不支持</td> <td>*</td> <td>需透明</td></tr> <tr><td>webp</td> <td>有损压缩</td> <td>支持</td> <td>支持</td> <td>chrom/oper</td> <td>复杂颜色和形状，浏览器已知</td></tr> <tr><td>svg</td> <td>无损压缩</td> <td>支持</td> <td>支持</td> <td>IE8↑/*</td> <td>简单</td></tr></tbody></table> <ol start="9"><li>split 数组去掉第三个元素</li></ol> <h2 id="解决跨域的方法"><a href="#解决跨域的方法" aria-hidden="true" class="header-anchor">#</a> 解决跨域的方法</h2> <p><a href="https://www.cnblogs.com/dhsz/p/6893682.html" target="_blank" rel="noopener noreferrer">JSONP<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>（1）jsonp 不安全的原因是 依赖后端，如果后端被攻击，返回一个病毒脚本。
（2）cros,前后端一起配合。后端修改请求的浏览器标识头。缺点是。不能同时处理多个不同源的请求
（3）proxy 前端框架的 webpack的代理请求。使用node模拟一个nginx请求。服务器请求服务器。获取数据
（4）nginx配置。直接就是服务器互相请求数据，不用前端配置</p> <ol start="11"><li><p>get post 请求的区别  不安全的原因 攻击 XXS</p></li> <li><p>this.$router和thi.$route的区别</p></li></ol> <p>this.$router是全局路由实例存在的方法是所有组件都可以使用，使用push  go  replace的方法进行跳转</p> <p>this.$route表示当前正在用于跳转的路由器对象，可以调用其name、path、query、params等方法；</p> <p>######## 瓜子</p> <h2 id="_1-手写一个防抖和一个节流"><a href="#_1-手写一个防抖和一个节流" aria-hidden="true" class="header-anchor">#</a> 1. 手写一个防抖和一个节流</h2> <p>防抖是将多次执行变为最后一次执行，节流是将多次执行变为在规定时间内只执行一次</p> <p>我们在操作的js的时候，有很多根据窗口尺寸，或者滚动加载事件来执行方法的。但是这种操作会及其频繁的占用浏览器性你那个</p> <p>所以我们设置一下，避免频繁调用方法，增加浏览器的负担</p> <p><strong>（1）防抖</strong></p> <p>防抖是在单位时间内。只要触发事件，调用方法的时间就会重新计算延迟。只有单位时间不再操作。才会调用一次方法。</p> <p>比如 持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p> <p>简单的防抖函数实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> _this <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">let</span> args <span class="token operator">=</span> arguments
    <span class="token comment">// 防抖事件，只要定时器存在。还一直频繁操作事件，我就一直给你清空，直到你停止</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>timer <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>delay<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">90909201902190</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'scroll'</span><span class="token punctuation">,</span> <span class="token function">debounce</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>应用场景:
两个条件:</p> <pre><code>1,如果客户连续的操作会导致频繁的事件回调(可能引起页面卡顿).

2,客户只关心&quot;最后一次&quot;操作(也可以理解为停止连续操作后)所返回的结果.

例如:

输入搜索联想，用户在不断输入值时，用防抖来节约请求资源。

按钮点击:收藏,点赞,心标等
</code></pre> <p><strong>(2) 节流</strong></p> <p>当用户操作持续出发事件的时候，保证一定时间内，只执行一次方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 定时器版本的节流</span>
<span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> args <span class="token operator">=</span> arguments
    <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token comment">// 如果频繁操作事件，定时器还在，什么都不执行，如果定时器不在了，设置一个定时器。</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span>args<span class="token punctuation">)</span>
        timer <span class="token operator">=</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>delay<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>(3) 总结</strong></p> <p>函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p> <p>函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</p> <p>区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p> <h2 id="_2-手写一个promise"><a href="#_2-手写一个promise" aria-hidden="true" class="header-anchor">#</a> 2. 手写一个promise</h2> <h2 id="_3-虚拟dom原理"><a href="#_3-虚拟dom原理" aria-hidden="true" class="header-anchor">#</a> 3. 虚拟dom原理</h2> <p>如果频繁操作dom，浏览器解析起来很费劲。性能就会很差。</p> <p>虚拟dom就是一个js对象。通过吧节点拆解成一个个的属性。进行保存，这样新老dom节点对比。就相当的快。</p> <p>vue的核心方法就是patch方法，就是把新老虚拟dom穿进去。进行对比。diff算法。</p> <p>前端diff算法一般都是同级对比。这样时间复杂度就是0(n).不会嵌套对比。提高性能</p> <p>vue的diff算法有个核心方法patch。先判断是不是属性一样，如果不一样。直接就替换，不走diff,一样再走diff</p> <p>diff算法 头头对比。尾尾对比。尾头对比。头尾对比  这是前四种</p> <p>还有一种就是新老虚拟dom全部不一样。</p> <h2 id="_4-手写apply-call，使用apply实现bind"><a href="#_4-手写apply-call，使用apply实现bind" aria-hidden="true" class="header-anchor">#</a> 4. 手写apply call，使用apply实现bind</h2> <p>区别是啥。</p> <p><strong>call</strong></p> <p>改变方法的this指向，需要一个个的传参</p> <p><strong>apply</strong></p> <p>改变方法的this指向，第二个参数可以是一个数组。不用一个个的写参数</p> <p><strong>bind</strong></p> <p>改变方法的this指向,同时不是直接执行方法。而是必须返回一个新的方法。再去执行</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 实现一个call的方法</span>
<span class="token comment">// 手动实现一个call</span>
    <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">call2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context <span class="token operator">=</span> window</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token comment">// context是传入的对象，this是指需要改变指向的那个函数，在目标对象上复制一个需要改变指向的方法</span>
      <span class="token keyword">let</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment">// 解析参数，第一个参数不要。因为是指向的对象。从第二个参数开始才是需要的</span>
      <span class="token keyword">let</span> result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token comment">// 目标对象上新复制的函数，执行一下，记得把处理的参数放进去。</span>
      <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn <span class="token comment">// 执行完。把添加的方法删了。要不然平白无故就会多出一个函数。上面已经改变了。</span>
      <span class="token keyword">return</span> result <span class="token comment">// 把结果返回啊</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> foo1 <span class="token operator">=</span> <span class="token punctuation">{</span>
      value<span class="token punctuation">:</span><span class="token number">5</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    bar<span class="token punctuation">.</span><span class="token function">call2</span><span class="token punctuation">(</span>foo1<span class="token punctuation">,</span><span class="token string">'back'</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">)</span>


</code></pre></div><h2 id="_5-发布订阅模式怎么实现？"><a href="#_5-发布订阅模式怎么实现？" aria-hidden="true" class="header-anchor">#</a> 5. 发布订阅模式怎么实现？</h2> <p>发布-订阅模式又叫观察者模式,它定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都将得到通知。</p> <p>发布订阅的实现思路是。定义一个对象</p> <p>对象里面</p> <ol><li>定义缓存事件的列表信息，</li> <li>订阅信息的方法，</li> <li>发布信息的方法</li></ol> <p>用户订阅消息的时候调用对象里面的订阅方法，吧自己的订阅信息添加到信息列表里面，数组或者对象</p> <p>发布消息的时候，调用发布方法，并且根据发布消息的参数去信息列表里面找对象的key，来执行响应的方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/*烧饼店  定义一个对象*/</span>         
<span class="token keyword">var</span> Sesamecakeshop<span class="token operator">=</span><span class="token punctuation">{</span>
    clienlist<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token comment">//缓存列表</span>
    <span class="token function-variable function">addlisten</span><span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//增加订阅者</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>clienlist<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">trigger</span><span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//发布消息</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>fn<span class="token punctuation">;</span>fn<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">.</span>clienlist<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/*小明发布订阅*/</span>
Sesamecakeshop<span class="token punctuation">.</span><span class="token function">addlisten</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">price<span class="token punctuation">,</span>taste</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;小明发布的&quot;</span><span class="token operator">+</span>price<span class="token operator">+</span><span class="token string">&quot;元，&quot;</span><span class="token operator">+</span>taste<span class="token operator">+</span><span class="token string">&quot;味道的&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*小龙发布订阅*/</span>
Sesamecakeshop<span class="token punctuation">.</span><span class="token function">addlisten</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">price<span class="token punctuation">,</span>taste</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;小龙发布的&quot;</span><span class="token operator">+</span>price<span class="token operator">+</span><span class="token string">&quot;元，&quot;</span><span class="token operator">+</span>taste<span class="token operator">+</span><span class="token string">&quot;味道的&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        

Sesamecakeshop<span class="token punctuation">.</span><span class="token function">trigger</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">&quot;椒盐&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_6-vue中-emit、-on实现机制"><a href="#_6-vue中-emit、-on实现机制" aria-hidden="true" class="header-anchor">#</a> 6. vue中$emit、$on实现机制</h2> <p>在vue内部初始化时会为每个组件实例挂载一个this._events私有的空对象属性：</p> <p>这个里面存放的就是当前实例上的自定义事件集合，也就是自定义事件中心，它存放着当前组件所有的自定义事件。和自定义事件相关的API分为以下四个：this.$on、this.$emit、this.$off、this.$once，它们会往这个事件中心中添加、触发、移除对应的自定义事件，从而组成了vue的自定义事件系统，</p> <p>说下自定义事件的机制。</p> <p>子组件使用this.$emit触发事件时，会在当前实例的事件中心去查找对应的事件，然后执行它。不过这个事件回调是在父组件的作用域里定义的，所以$emit里的参数会传递给父组件的回调函数，从而完成父子组件通信。</p> <p>父子组件通信的原理</p> <div class="language- extra-class"><pre class="language-text"><code>父子组件通过自定义事件通信，自定义事件的实现原理和通常解释的会不同，
它们的原理是父组件在经过编译模板后，会将定义在子组件上的自定义事件test及其回调handleTest通过$on添加到子组件的事件中心中，
当子组件通过$emit触发test自定义事件时，会在它的事件中心中去找test，找到后传递hello-vue~给回调函数并执行，
不过因为回调函数handleTest是在父组件作用域内定义的，所以看起来就像是父子组件之间通信般。
</code></pre></div><h2 id="_7-闭包应用"><a href="#_7-闭包应用" aria-hidden="true" class="header-anchor">#</a> 7. 闭包应用</h2> <p>检测字符串是不是第一次传入</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'已存在'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'首次传入'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">isFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">result</span><span class="token punctuation">(</span><span class="token string">'试试水'</span><span class="token punctuation">)</span>
<span class="token function">result</span><span class="token punctuation">(</span><span class="token string">'试水'</span><span class="token punctuation">)</span>
<span class="token function">result</span><span class="token punctuation">(</span><span class="token string">'试试水'</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="_8-computed、methods区别"><a href="#_8-computed、methods区别" aria-hidden="true" class="header-anchor">#</a> 8. computed、methods区别</h2> <ol><li>计算属性有缓存，计算属性会把函数执行一次，把结果存起来，依赖的值改变，会重新赋值。</li> <li>函数是每次模板编译都会执行。只要有响应式属性改变，视图刷新，函数就执行。</li></ol> <h2 id="_9-懒加载的实现原理"><a href="#_9-懒加载的实现原理" aria-hidden="true" class="header-anchor">#</a> 9. 懒加载的实现原理</h2> <p>图片懒加载技术主要通过监听图片资源容器是否出现在视口区域内，来决定图片资源是否被加载。
那么实现图片懒加载技术的核心就是如何判断元素处于视口区域之内。</p> <p><strong>以前</strong></p> <p>以前的懒加载核心技术原理就是通过js提供的element.getBoundingClientRect()</p> <ol><li>给图片容器自定义属性，不赋值真实图片连接，</li> <li>利用scroll事件， Element.getBoundingClientRect() 方法判断目标容器是否给跟可视区域交叉了</li> <li>判断交叉了 就 把真实链接赋值给图片容器，显示内容</li></ol> <p>注意使用的时候 scroll事件记得使用节流，避免一直触发操作事件，影响性能</p> <p><strong>现在</strong></p> <p>Web为开发者提供了 IntersectionObserver 接口它
可以异步监听目标元素与其祖先或视窗的交叉状态，
注意这个接口是异步的，它不随着目标元素的滚动同步触发，所以它并不会影响页面的滚动性能。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> io <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> options<span class="token punctuation">)</span>


<span class="token comment">// 用来指定交叉比例，决定什么时候触发回调函数，是一个数组，默认是[0]。</span>

<span class="token comment">// 我们指定了交叉比例为0，0.5，1，当观察元素img0%、50%、100%时候就会触发回调函数</span>
<span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>
    root<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    threshold<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> io <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
io<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="_10-其他问题"><a href="#_10-其他问题" aria-hidden="true" class="header-anchor">#</a> 10. 其他问题</h2> <ol start="2"><li>常见的web安全问题都有哪些?怎么处理
xss 跨站脚本请求   csrf 伪请求</li> <li>h5页面加载百分比进度条变化机制</li> <li>生产上出现白屏怎么处理?(抓包机制)</li> <li>抓包</li> <li>怎么监控与原生通信时的异常</li> <li>http缓存
分为强缓存，弱缓存</li> <li>http1  http1.1  http2
HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li></ol> <p>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；，HTTP1.x的解析是基于文本。基于文本协议的格式解析</p> <p>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；HTTP2.0的协议解析决定采用二进制格式</p> <ol><li><p>响应式原理本质就是数据劫持和发布订阅模式</p></li> <li><p>数据劫持。就是把数据每一个属性转换成可以被检测</p></li></ol> <p>3.订阅就是属性所有读取或修改被观察者订阅</p> <p>当修改的时候，发布通知。调用回调函数进行相应的改变</p> <ol start="4"><li>看一下vue的源码主要就是三个大类，核心  Observal   Dep   Watcher</li></ol> <p>（1）Observal类定义了几个方法。目的就是吧对象的所有属性使用object.defineProperty转换为可以被检测。</p> <p>同时在get里面dep.depend手收集依赖。在get里面dep.notify派发更新</p> <p>（2）Dep类是Observal和watcher的桥梁。里面定义了depend的方法，用来依赖收集。放进去subs数组。定义了notify的范发给。用来执行watcher订阅者的
回调函数派发更新</p> <p>（3）Watcher累是一个监听器。定义的方法是将自己实例添加到Dep类subs数组中。完成订阅。自己内部定义了update的回调更新方法，当派发通知下来的时候，执行。更新页面等操作。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 防抖函数， 单位时间频繁操作，方法不执行，直到过去单位时间才触发方法，一般解决滚动加载</span>
<span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>delay</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> args <span class="token operator">=</span> arguments
    <span class="token keyword">if</span><span class="token punctuation">(</span> timer <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span>args<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>delay<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/Interview/" class="prev router-link-active">
          Js基础知识面试
        </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.296096c9.js" defer></script><script src="/assets/js/2.93ca5cf4.js" defer></script><script src="/assets/js/21.050f4549.js" defer></script>
  </body>
</html>
